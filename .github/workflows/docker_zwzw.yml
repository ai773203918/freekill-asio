name: Docker Build and Publish

on:
  # 每天检查一次新版本
  schedule:
    - cron: '0 2 * * *'  # 每天凌晨2点运行
  # 允许手动触发
  workflow_dispatch:

jobs:
  # =================================================================
  # 作业 1: 检查版本和是否需要构建
  # 这个作业作为入口，获取信息并决定后续流程。
  # =================================================================
  check-version:
    runs-on: ubuntu-latest
    # 定义输出变量，供其他作业使用
    outputs:
      version: ${{ steps.get_version.outputs.version }}
      build_needed: ${{ steps.get_version.outputs.build_needed }}
    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Get latest release version
      id: get_version
      run: |
        # 获取最新版本号
        LATEST_VERSION=$(curl -s https://api.github.com/repos/Qsgs-Fans/freekill-asio/releases/latest | grep '"tag_name":' | sed -E 's/.*"([^"]+)".*/\1/' | sed 's/v//')
        echo "Latest version: $LATEST_VERSION"
        echo "version=$LATEST_VERSION" >> $GITHUB_OUTPUT
        
        # 检查是否是手动触发
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          echo "Manual trigger, skipping Docker Hub check"
          echo "build_needed=true" >> $GITHUB_OUTPUT
        else
          echo "Automatic trigger, checking Docker Hub"
          # 检查Docker Hub上是否已有该版本的镜像
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" "https://hub.docker.com/v2/repositories/${{ secrets.DOCKERHUB_USERNAME }}/freekill-asio/tags/$LATEST_VERSION/")
          
          if [ "$HTTP_STATUS" = "200" ]; then
            echo "Version $LATEST_VERSION already exists on Docker Hub"
            echo "build_needed=false" >> $GITHUB_OUTPUT
          else
            echo "Version $LATEST_VERSION is new, building image"
            echo "build_needed=true" >> $GITHUB_OUTPUT
          fi
        fi

  # =================================================================
  # 作业 2: 并行构建各平台镜像
  # 使用矩阵策略为每个目标平台创建一个独立的构建任务。
  # =================================================================
  build:
    # 依赖于 check-version 作业，并使用其输出
    needs: check-version
    # 只有在需要构建时才运行此作业
    if: needs.check-version.outputs.build_needed == 'true'
    runs-on: ubuntu-latest
    # 关键设置 1: 矩阵策略
    strategy:
      # 关键设置 2: 允许失败，不因单个平台失败而终止其他平台的构建
      fail-fast: false
      matrix:
        # 定义需要构建的平台列表
        platform:
          - linux/amd64
          - linux/arm64
          - linux/arm/v7
          - linux/arm/v6
          - linux/386
        # 为每个平台定义一个用于标签的简短架构名，便于后续识别
        include:
          - platform: linux/amd64
            arch: amd64
          - platform: linux/arm64
            arch: arm64v8
          - platform: linux/arm/v7
            arch: arm32v7
          - platform: linux/arm/v6
            arch: arm32v6
          - platform: linux/386
            arch: i386

    steps:
    - name: Checkout repository
      uses: actions/checkout@v3
      
    - name: Set up QEMU
      # 用于模拟非 x86 架构，是跨平台构建的必要组件
      uses: docker/setup-qemu-action@v2
      with:
        platforms: ${{ matrix.platform }}
      
    - name: Set up Docker Buildx
      # Docker Buildx 是用于构建多平台镜像的工具
      uses: docker/setup-buildx-action@v2
      
    - name: Login to Docker Hub
      uses: docker/login-action@v2
      with:
        username: ${{ secrets.DOCKERHUB_USERNAME }}
        password: ${{ secrets.DOCKERHUB_PASSWORD }}

    - name: Build and push single-arch image
      uses: docker/build-push-action@v4
      with:
        context: .
        push: true
        # 关键设置 3: 为每个架构打一个唯一的、临时的标签。
        # 例如: v1.0.0-amd64, v1.0.0-arm64v8
        # 这些标签是中间产物，用于下一步的合并。
        tags: |
          ${{ secrets.DOCKERHUB_USERNAME }}/freekill-asio:${{ needs.check-version.outputs.version }}-${{ matrix.arch }}
        platforms: ${{ matrix.platform }}
        build-args: |
          VERSION=${{ needs.check-version.outputs.version }}

    # =================================================================
    # 作业 3: 合并多架构镜像并创建最终标签 (修正版)
    # 这个作业负责将所有成功构建的单架构镜像合并成一个统一的多架构镜像。
    # =================================================================
    create-manifest:
      # 依赖于 check-version 和 build 作业
      needs: [check-version, build]
      # 关键设置: 即使 build 矩阵中有作业失败，此作业也始终运行。
      # 这确保了只要有任何一个平台构建成功，我们就能尝试创建最终镜像。
      if: always() && needs.check-version.outputs.build_needed == 'true'
      runs-on: ubuntu-latest
      steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_PASSWORD }}

      - name: Create and push multi-arch manifest (Robust Version)
        run: |
          # 从 check-version 作业获取版本号
          VERSION="${{ needs.check-version.outputs.version }}"
          DOCKERHUB_USERNAME="${{ secrets.DOCKERHUB_USERNAME }}"
          IMAGE_NAME="$DOCKERHUB_USERNAME/freekill-asio"
          
          # 定义所有可能存在的架构标签列表
          ALL_TAGS=(
            "$IMAGE_NAME:$VERSION-amd64"
            "$IMAGE_NAME:$VERSION-arm64v8"
            "$IMAGE_NAME:$VERSION-arm32v7"
            "$IMAGE_NAME:$VERSION-arm32v6"
            "$IMAGE_NAME:$VERSION-i386"
          )
          
          # 创建一个空数组，用于存放实际存在的标签
          VALID_TAGS=()
          
          echo "Checking for successfully built images..."
          
          # 遍历所有可能的标签
          for TAG in "${ALL_TAGS[@]}"; do
            # 使用 docker buildx imagetools inspect 检查标签是否存在
            # 如果镜像不存在，此命令会返回一个非零的退出码
            if docker buildx imagetools inspect --format='{{.Manifest}}' "$TAG" > /dev/null 2>&1; then
              echo "✅ Found: $TAG"
              # 将存在的标签添加到 VALID_TAGS 数组中
              VALID_TAGS+=("$TAG")
            else
              echo "❌ Not found: $TAG, skipping."
            fi
          done
          
          # 检查是否找到了任何有效的标签
          if [ ${#VALID_TAGS[@]} -eq 0 ]; then
            echo "Error: No images were successfully built. Cannot create manifest."
            exit 1 # 如果没有镜像，则失败，这使得整个工作流失败，这是正确的行为
          fi
          
          echo "-----------------------------------------"
          echo "Creating manifest with the following tags:"
          printf '  %s\n' "${VALID_TAGS[@]}"
          echo "-----------------------------------------"
          
          # 使用找到的有效标签创建并推送多架构清单
          # 这次我们传递给命令的标签都是确定存在的，所以命令一定会成功
          docker buildx imagetools create \
            -t "$IMAGE_NAME:$VERSION" \
            -t "$IMAGE_NAME:latest" \
            "${VALID_TAGS[@]}"
          
          echo "Successfully created manifest for $IMAGE_NAME:$VERSION and $IMAGE_NAME:latest"
